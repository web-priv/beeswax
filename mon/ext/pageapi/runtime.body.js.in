/**
    Beeswax - Anti-Exfiltration Web Platform
    Copyright (C) 2016  Jean-Sebastien Legare

    Beeswax is free software: you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    Beeswax is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with Beeswax.  If not, see
    <http://www.gnu.org/licenses/>.
**/


/*global
  Promise,
  Element, Event, EventTarget, Window
*/
/*jshint: es5: true */

//# include "../config.h"

function (G) {
    "use strict";

    var CRYPTO_PAGE_TO_CS = "_beeswax_crypto_page_to_cs";
    var CRYPTO_CS_TO_PAGE = "_beeswax_crypto_cs_to_page";
    var API_GLOBAL = "_M";

    var closureIsMaimed = false;

    function E(code, message) {
        var stack = (new G.Error().stack);
        this.message = message || "Fail";
        this.code = (code === undefined) ? E.GENERIC:code;
        this.name = "E";
        var skip2 = G.String_indexOf(stack, ["\n", G.String_indexOf(stack, ["\n"]) + 1]);
        this.stack = "E" + G.String_substr(stack, [skip2]);
    }
    E.prototype = G.Object_create(G.Error.prototype);
    E.prototype.constructor = E;
    E.fromVal = function (thing) {
        switch (typeof thing) {
        case "undefined":
            G.console_error("undefined error value.");
            return new E(E.GENERIC);
        case "object":
            if (thing === null) {
                G.console_error("null error value");
                return new E(E.GENERIC);
            }

            if (thing instanceof String) {
                return new E(thing);
            }

            if (thing.code) {
                return new E(thing.code, thing.message);
            } else {
                G.console_error("unfamiliar error value");
                return new E(E.GENERIC);
            }
            break;
        case "string":
            return new E(thing);
        }
    };

    E.INVALID_RPC  = "INVALID_RPC";
    E.BADPARAM     = "BADPARAM";
    E.KAPERROR     = "KAPERROR";
    E.NOKEY        = "NOKEY";
    E.NOENT        = "NOENT";
    E.GENERIC      = "GENERIC";
    E.NOKEYRING    = "NOKEYRING";
    E.EXISTS       = "EXISTS";
    E.OPENKEYRING  = "OPENKEYRING";
    E.BADTYPE      = "BADTYPE";
    E.MAIMED       = "MAIMED";
    E.INVALIDPAREA = "INVALIDPAREA";
    E.INVALIDKEY   = "INVALIDKEY";
    E.NOIDENT      = "NOIDENT";
    E.REFUSED      = "REFUSED";

    /* Responsible to talk with the extension via a secure channel */
    function MicasaMonitor() {
        this.page_to_cs_event = null;
        this.callcount = 0;
        this.pendingRPC = {};
        this._initialize();
        this._msgHandlers = [];
        this._collectStats = null;
    }

    MicasaMonitor.prototype = {
        _initialize: function () {
            var that = this;

            this.page_to_cs_event = G.document_createEvent("Event");
            //create event in DOM, bubble is false, cancelable is false
            G.Event_initEvent(this.page_to_cs_event, [CRYPTO_PAGE_TO_CS, false, false]);

            function handler(/* evt */) {
                var respStr = G.Element_getAttribute(G.documentElement, [CRYPTO_CS_TO_PAGE]);
                G.Element_setAttribute(G.documentElement, [CRYPTO_CS_TO_PAGE, ""]);
                var response = G.JSON_parse(respStr);
                var respId = response.callid;
                var i, hdls;

                if (respId === undefined) {
                    //G.console_log("Received extension message:", response);
                    hdls = G.Array_slice(that._msgHandlers);
                    for (i = 0; i < hdls.length; i++) {
                        try {
                            hdls[i](response.msg);
                        } catch (err) {
                            G.console_error("[Micasa] Event dispatch error:", err);
                        }
                    }
                    return;
                }

                if (G.Object_hasOwnProperty(that.pendingRPC, [respId])) {
                    var pending = that.pendingRPC[respId];
                    delete that.pendingRPC[respId];

                    if (response.times) {
                        response.times.end = G.performance_now();
                        if (that._collectStats) {
                            that._collectStats.push(response.times);
                        }
                    }

                    if (G.Object_hasOwnProperty(response, ["error"]) && !!response.error) {
                        if (pending.errorcb) {
                            G.setTimeout(function () {
                                pending.errorcb(E.fromVal(response.error));
                            }, 0);
                        }
                    } else {
                        if (pending.cb) {
                            G.setTimeout(function () { pending.cb(response.result); }, 0);
                        }
                    }
                } else {
                    G.console_error("Could not match response for response ID", respId);
                    return;
                }
            }

            G.EventTarget_addEventListener(G.documentElement, [CRYPTO_CS_TO_PAGE, handler]);
        },
        
        send: function (cmd, opts) {
            var callid = this.callcount++;
            var that = this;

            return new Promise(function (resolve, reject) {
                that.pendingRPC[callid] = {
                    callid: callid,
                    cb: resolve,
                    errorcb: reject
                };
                
                G.Element_setAttribute(G.documentElement, [CRYPTO_PAGE_TO_CS, JSON.stringify({
                    cmd: cmd,
                    callid: callid,
                    params: opts.params,
                    times: {
                        cmd: cmd,
                        start: performance.now()
                    }
                })]);

                G.EventTarget_dispatchEvent(G.documentElement, [that.page_to_cs_event]);
            });
        },

        addHandler: function (typ, func) {
            this.removeHandler(typ, func);
            switch (typ) {
            case "message":
                this._msgHandlers.push(func);
                break;
            default:
                throw new E(E.BADTYPE, "no such event");
            }
        },

        removeHandler: function (typ, func) {
            var i;
            var hdls = this._msgHandlers;

            switch (typ) {
            case "message":
                for (i = 0; i < hdls.length; i++) {
                    if (hdls[i] === func) {
                        this._msgHandlers = G.Array_slice(hdls, [i, 1]);
                        return;
                    }
                }
                break;
            default:
                throw new E(E.BADTYPE, "no such event");
            }
        }
    };

    /* Performs runtime checks on the application */
    function MicasaRuntime(mon) {
        this.privateEltCounter = 0;
        this.mon = mon;
        this.eventListeners = {};
        this.knownEvents = {};
        this.usedShadowRoots = false;
        this.inUse = false;
        this._protectEnvironment();
    }

    function hasValueProp(obj, propName, expect) {
        var desc = G.Object_getOwnPropertyDescriptor(obj, propName);

        if (desc === undefined) {
            return false;
        }

        if (!G.Object_hasOwnProperty(desc, ["value"]) ||
            G.Object_hasOwnProperty(desc, ["get"]) ||
            G.Object_hasOwnProperty(desc, ["set"])) {
            return false;
        }

        if (expect !== undefined) {
            if (expect.enumerable !== undefined) {
                if (expect.enumerable !== expect.enumerable) {
                    return false;
                }
            }
            
            if (expect.configurable !== undefined) {
                if (desc.configurable !== expect.configurable) {
                    return false;
                }
            }

            if (expect.writable !== undefined) {
                if (desc.writable !== expect.writable) {
                    return false;
                }
            }
        }
               
        return desc;
    }

    var _GET = {
        "null": function () { return null; },
        "undefined": function () { return; },
        0: function () { return 0; },
        "": function () { return ""; },
        "true": function () { return true; },
        "false": function () { return false; }
    };

    MicasaRuntime.prototype = {
        /* return the names of all the onx event listener hooks
           (e.g. onload, onmousemove, etc) that exist on the given objects
        */
        _findOnHooks: function (obj, nameSet) {
            var i, attrs = G.Object_getOwnPropertyNames(obj);
            var attrname, evtname;

            nameSet = nameSet || {};

            for (i = 0; i < attrs.length; i++) {
                attrname = attrs[i];
                
                if (attrname.length >= 3 &&
                    G.String_substr(attrname, [0, 2]) === "on" &&
                    G.String_toLowerCase(attrname, []) === attrname) {
                    evtname = G.String_substr(attrname, [2]);
                    nameSet[evtname] = (nameSet[evtname] || 0) + 1;
                }
            }

            return nameSet;
        },

        _getEventProtoName: function (evt) {
            var evtProto = G.Object_getPrototypeOf(evt);
            if (!hasValueProp(evtProto, "micasa_prototype_name", {configurable: false, writable: false})) {
                G.console_error("Cannot derive prototype name from event object:", evt);
                return null;
            }
            return evtProto.micasa_prototype_name;
        },

        /*
          Delete attributes on the event that are pointing to private
          elements.  Return null if any attribute cannot be
          deleted. The event propagation should be aborted if this is
          the case.

          matchProps is an object with property names as keys. Those
          attributes are checked for private markers. properties in
          matchProps that refer to private elements or private host
          elements are set to null. use a true value to indicate that
          the property must be present on the object, false when
          optional.

          deleteProps is an object with additional property names as
          keys. If any of matchProps properties match a private
          element, each property contained in deleteProps is set on
          the event to the value associated with the key.

        */
        sanitizeEventAttrs: function (evt, matchProps, deleteProps) {
            var propName;
            var propVal;
            var deleted = {};
            var numDeleted = 0;
            var isMatched = false;
            var getter = null;

            function _retrieveGetter(protoName, propName) {
                var descs;
                for (descs = G.Event_descriptors[protoName]; descs !== null; descs = descs.parent) {
                    if (G.Object_hasOwnProperty(descs.getters, [propName])) {
                        return descs.getters[propName];
                    }
                }
                return null;
            }

            var protoName = this._getEventProtoName(evt);

            for (propName in matchProps) {
                if (G.Object_hasOwnProperty(matchProps, [propName])) {
                    if (hasValueProp(evt, propName)) {
                        G.console_error("Expected event to use getters/setters. not own properties.", propName, evt);
                        return null;
                    }

                    getter = _retrieveGetter(protoName, propName);
                    if (getter === null) {
                        if (!matchProps[propName]) {
                            //optional
                            continue;
                        }
                        G.console_error("Expected event to have property:", propName, evt);
                        return null;
                    }
                    propVal = getter(evt);
                    if (!(propVal instanceof G.Node)) {
                        continue;
                    }

                    /* IMPORTANT: Assumes all the children nodes of a private element are also marked Private.
                       Otherwise we have to walk up the tree. */
                    if (this.isPrivateElt(propVal) || this.isPrivateHost(propVal)) {
                        G.Object_defineProperty(evt, propName, {configurable: false, get: _GET["null"]});
                        deleted[propName] = propVal;
                        numDeleted += 1;
                        isMatched = true;
                    }

                }
            }
            
            if (isMatched === true) {
                for (propName in deleteProps) {
                    if (G.Object_hasOwnProperty(deleteProps, [propName])) {
                        getter = _retrieveGetter(protoName, propName);
                        propVal = getter(evt);

                        // This is checked by the overridden getters. (see function allowGetterInterposition())
                        G.Object_defineProperty(evt, "_micasa_getter_" + propName, {
                            configurable: false,
                            enumerable: false,
                            writable: true,
                            value: deleteProps[propName]
                        });
                        if (!hasValueProp(evt, "_micasa_getter_" + propName, {configurable: false})) {
                            G.console_error("[Micasa] Could not override value for getter:", protoName, ".", propName);
                            return null;
                        }
                        deleted[propName] = propVal;
                        numDeleted += 1;
                    }
                }
            }
            deleted.numDeleted = numDeleted;
            return deleted;
        },

        sanitizeEventFull: function (evt) {
            var evtProps;
            var unhandled = {};
            var deleted = {}, matched = {};
            var numDeleted = 0;
            var propName, i, propVal;
            var isMatched = false;
            var protoName;

            function wipe(propName, protoName) {
                // This is checked by the overridden getters. (see function allowGetterInterposition())
                G.Object_defineProperty(evt, "_micasa_getter_" + propName, {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: null
                });
                if (!hasValueProp(evt, "_micasa_getter_" + propName, {configurable: false})) {
                    G.console_error("[Micasa] Could not override value for getter:", protoName, ".", propName);
                    return null;
                }


                G.Object_defineProperty(evt, propName, {configurable: false, get: _GET["null"]}); //evt[propName] = null;
                deleted[propName] = null;
                numDeleted += 1;
                return true;
            }

            function unknown(propName, propVal) {
                unhandled[propName] = propVal;
            }

            // gets a dictionary of all getters found on a prototype
            // chain for a subprototype of Event.
            function getPropDict(protoName) {
                var descs, props = {};
                var propName;
                for (descs = G.Event_descriptors[protoName]; descs !== null; descs = descs.parent) {
                    for (propName in descs.getters) {
                        if (G.Object_hasOwnProperty(descs.getters, [propName])) {
                            if (!G.Object_hasOwnProperty(props, [propName])) {
                                props[i] = descs.getters[propName];
                            }
                        }
                    }
                }
                return props;
            }

            protoName = this._getEventProtoName(evt);
            if (!protoName) {
                return null;
            }

            evtProps = getPropDict(protoName);

            for (propName in evtProps) {
                if (G.Object_hasOwnProperty(evtProps, [propName])) {
                    propVal = evtProps[propName](evt);
                    if (propVal instanceof G.Node) {
                        if (this.isPrivateElt(propVal)) {
                            if (!wipe(propName, protoName)) {
                                return null;
                            }
                            matched[propName] = propVal;
                            isMatched = true;
                        }
                    } else if (propVal instanceof G.Array) {
                        if (propVal.length > 0) {
                            unknown(propName, propVal);
                        }
                        // length 0 ok
                    } else {
                        // FIXME inspect properties that are not identified.
                        unknown(propName, propVal);
                    }
                }
            }

            if (isMatched === true) {
                G.console_error("[Micasa] Event (type=" + evt.type + ") references private element. Fields with private elements:", matched, "unhandled:", unhandled);
            }

            deleted.numDeleted = numDeleted;
            return deleted;
        },

        /* Micasa event handler for all events */
        eventCapture: function (evt) {
            var erased = null;
            var evtName = null;

            function abortEvt(msg) {
                if (msg !== undefined) {
                    G.console_error(msg);
                }
                G.Event_prototype_stopImmediatePropagation(evt, []);
                return false;
            }

            // since M43 these attributes are no longer defined directly on the event
            // object. a prototype chain lookup is required.
            // if (!hasValueProp(evt, "target", {configurable: true, writable: true})) {
            //     return abortEvt("Event target property has been redefined");
            // }

            if (evt instanceof G.DeviceOrientationEvent ||
               evt instanceof G.DeviceMotionEvent ||
               evt instanceof G.PageTransitionEvent ||
               evt instanceof G.HashChangeEvent ||
               evt instanceof G.PopStateEvent ||
               evt instanceof G.ErrorEvent ||
               evt instanceof G.StorageEvent) {
                
                // On window only events
                return true;
            }

            // Created by the application or the content script.  No
            // need for sanitization (the ones in the content script
            // are created with care to not reveal any confidential
            // material).
            if (evt instanceof G.CustomEvent) {
                return true;
            }

            var isTrusted = G.Object_getOwnPropertyDescriptor(evt, "isTrusted");
            if (!isTrusted || isTrusted.configurable) {
                //debugger;
                return abortEvt("[Micasa] Event has no isTrusted own property");
            }

            if (G.Event_prototype_target(evt) === undefined) {
                return abortEvt("[Micasa] Captured an event with no target");
            }


            if (evt instanceof G.MouseEvent) {
                erased = this.sanitizeEventAttrs(evt, {"toElement": 1, "fromElement": 1, "relatedTarget": 1, "currentTarget": 1});
                evtName = "MouseEvent";
            } else if (evt instanceof G.KeyboardEvent) {

                erased = this.sanitizeEventAttrs(evt,
                                                {toElement: 0, srcElement: 1, currentTarget: 1, target: 1},
                                                {keyCode: 0, keyIdentifier: "", charCode: 0, metaKey: false, repeat: false,
                                                 shiftKey: false, ctrlKey: false, which: 0});
                evtName = "KeyboardEvent";
            } else if (evt instanceof G.MessageEvent) {
                erased = this.sanitizeEventAttrs(evt,
                                                 {target: 1, srcElement: 1, currentTarget: 1},
                                                 {data: ""});
            } else if (evt instanceof G.FocusEvent) {
                erased = this.sanitizeEventAttrs(evt,
                                                 {target: 1, currentTarget: 1, relatedTarget: 1},
                                                 {});
            } else if ((evt instanceof G.TransitionEvent) ||
                       (evt instanceof G.StorageEvent)) {
                erased = this.sanitizeEventAttrs(evt,
                                                 {target: 1, currentTarget: 1, relatedTarget: 0},
                                                 {});
            } else if (G.Object_getPrototypeOf(evt) === G.Event_prototype) {

                // Exactly an Event. Not a subclass.

                var evtType = G.Event_prototype_type(evt);
                evtName = "Event." + evtType;
                switch (evtType) {
                case "DOMContentLoaded":
                case "readystatechange":
                case "scroll":
                case "load":
                case "resize":
                case "focus":
                case "focusout":
                case "blur":
                case "unload":
                case "reset":
                case "change":
                case "input":
                    erased = this.sanitizeEventAttrs(evt,
                                                     {srcElement: 1, currentTarget: 1, target: 1, relatedTarget: 0},
                                                     {});
                    break;
                default:
                    G.console_warn("Defaulting to slow event sanitization:", evt.constructor.name, evt.type, evt);
                    erased = this.sanitizeEventFull(evt);
                }
            } else {
                G.console_warn("Defaulting to slow event sanitization:", evt.constructor.name, evt.type, evt);
                erased = this.sanitizeEventFull(evt);
            }

            if (erased === null) {
                return abortEvt("Could not sanitize event: " + (evtName !== null ? evtName : "Event"));
            }
        },
        /*
          Let micasa be the first handler to receive this type of
          event.  We set on window because it's the first object to
          receive it in the capture phase.
        */
        _registerEventListenerType: function (type) {
            var eventCapture = this.eventCapture.bind(this);
            
            if (this.eventListeners[type] === undefined) {
                this.eventListeners[type] = eventCapture;
                G.EventTarget_addEventListener(G.window, [type, eventCapture, true]);
            }
        },

        _protectEnvironment: function () {
            var that = this;

            //
            // Install the handler on demand
            function addEventListener(type, listener, useCapture) {
                type = "" + type;
                useCapture = !!useCapture; // default false
                if (!type || (typeof listener) !== "function") {
                    return;
                }

                if (that.eventListeners[type] === undefined) {
                    that._registerEventListenerType(type);
                }

                // Let the call through
                /*jshint validthis: true*/
                return G.EventTarget_addEventListener(this, [type, listener, useCapture]);
            }

            // Override addEventListener
            G.EventTarget_prototype.addEventListener = addEventListener;

            function querySelector(s) {
                //FIXME less false negatives
                if (G.String_indexOf(s, ["::shadow"]) !== -1) {
                    G.console_error("Can't use shadow selector");
                    throw new Error("::shadow not allowed");
                }
                return G.document_querySelector(s);
            }

            function querySelectorAll(s) {
                //FIXME less false negatives
                if (G.String_indexOf(s, ["::shadow"]) !== -1) {
                    G.console_error("Can't use shadow selector");
                    throw new Error("::shadow not allowed");
                }
                return G.document_querySelectorAll(s);
            }

            G.Document_prototype.querySelectorAll = querySelectorAll;
            G.Document_prototype.querySelector = querySelector;

            /*
              We need to freeze Object.prototype to prevent new
              properties to be added to objects. Adding properties to
              Object.prototype with names matching some of the names
              of attributed used in this code opens the possibility of
              exfiltrating data through setters.

              Freezing the prototype with Object.freeze prevents the
              addition of new properties, but also has the side effect
              of preventing subclasses of object to override methods
              using assignments.

              e.g. The following no longer works with frozen Object.prototype:

                function Cat() {}
                Cat.prototype.toString = function () { return "meow"; }

              However the following two (equivalent) methods still work:

                function Cat() {}
                Cat.prototype = { toString: function () { return "meow"; } };

                function Cat() {}
                Object.defineProperty(Cat.prototype, "toString", {
                   value: function () { return "meow"; }
                });

              The difference is subtle. In the first case, the
              assignment first causes a lookup up the prototype chain,
              and retrieves the non-configurable property (frozen) on
              Object.prototype. In the two other cases, a new property
              descriptor is created on the subclass prototype.

            */
            function freezeObject() {
                var controlled = { toString: G.Object_toString,
                                   toLocaleString: G.Object_toLocaleString,
                                   valueOf: G.Object_valueOf,
                                   constructor: Object.prototype.constructor
                                 };

                function controlledProp(name) {
                    function getter() {
                        return controlled[name];
                    }
                    
                    function setter(newval) {
                        /*jshint validthis: true */

                        /* Don't set anything on Object.prototype. Bad
                           Form.  Redefinitions on subclasses are OK
                           (and actually necessary for many sites to
                           work right).
                        */
                        if (this !== G.Object_prototype) {
                            //debugger;
                            G.Object_defineProperty(this, name, {
                                value: newval,
                                configurable: true,
                                writable: true,
                                enumerable: true
                            });
                        }
                    }
                    return {get: getter, set: setter};
                }

                for (var name in controlled) {
                    if (G.Object_hasOwnProperty(controlled, [name])) {
                        G.Object_defineProperty(G.Object_prototype, name,
                                                controlledProp(name));
                    }
                }

                G.Object_freeze(G.Object_prototype);
            
                // Assert that we can't mess with array length
                if (G.Object_getOwnPropertyDescriptor([], "length").configurable !== false) {
                    G.console_error("Array length can be overridden.");
                    that.maim();
                }
            }
            
            freezeObject();

            /* Find all onx hooks (Dom level2).
               We make sure to be the first to catch events that can be listened to using
               onx hooks, e.g., x.onmouseover;
             */
            function listenToOnHooks() {
                // Listen to every hook that we can find.
                var hooksSet = {};

                // Look for hooks on the following elements.
                var eventTargets = [ G.window,
                                     G.Window_prototype,
                                     G.document,
                                     G.document_createElement("div"),
                                     G.documentElement,
                                     G.document_createElement("img"),
                                     G.document_createElement("video"),
                                     G.document_createElement("audio")
                                   ];

                for (var i = 0; i < eventTargets.length; i++) {
                    that._findOnHooks(eventTargets[i], hooksSet);
                }


                for (var hookType in hooksSet) {
                    if (G.Object_hasOwnProperty(hooksSet, [hookType])) {
                        if (hookType !== "error") {
                            that._registerEventListenerType(hookType);
                        }
                    }
                }
            }

            listenToOnHooks();

            var len = G.Object_getOwnPropertyNames(that.eventListeners).length;
            G.console_log("Listening to", len, "event types.");

            /*
              We need to rely on the string name of the various event
              object prototypes to establish fast mappings between
              event objects and their descriptors.  Because the name
              is on the 'constructor' property
              (i.e., evt.__proto__.constructor.name), and the constructor
              property can be overridden, we add a special non
              configurable property to the event prototypes.
            */
            function lockEventPrototypeNames() {
                var names = G.Object_getOwnPropertyNames(G);
                var i, name, eventProto, count = 0;
                for (i = 0; i < names.length; i++) {
                    name = names[i];
                    if (G.String_substr(name, [name.length - "Event_prototype".length]) === "Event_prototype") {
                        eventProto = G[name];
                        // some prototypes are aliases
                        // (e.g. AnimationEvent, WebKitAnim...), so we
                        // check before redefining.
                        if (!G.Object_hasOwnProperty(eventProto, ['micasa_prototype_name'])) {
                            count += 1;
                            G.Object_defineProperty(eventProto, 'micasa_prototype_name', {
                                configurable: false,
                                enumerable: false,
                                value: eventProto.constructor.name,
                                writable: false
                            });
                        }
                    }
                }
                G.console_log("Registered", count, "event prototypes");
            }
            lockEventPrototypeNames();

            function allowGetterInterposition() {
                var getters, getterName;
                var protoName, desc, proto;

                function mkgetter(lookupName, orig) {
                    return function () {
                        if (G.Object_hasOwnProperty(this, [lookupName])) {
                            return this[lookupName];
                        } else {
                            return orig(this);
                        }
                    };
                }

                for (protoName in G) {
                    if (G.String_substr(protoName, [protoName.length - "Event_prototype".length]) === "Event_prototype") {
                        proto = G[protoName];
                        protoName = proto.micasa_prototype_name; // short name (lose the "webkit" prefix if applicable)
                        getters = G.Event_descriptors[protoName].getters;

                        for (getterName in getters) {
                            if (G.Object_hasOwnProperty(getters, [getterName])) {
                                desc = G.Object_getOwnPropertyDescriptor(proto, getterName);
                                if (!desc.configurable) {
                                    G.console_warn("[Micasa] Property " + protoName + "." + getterName, "is not configurable");
                                }
                                desc.get = mkgetter("_micasa_getter_" + getterName, getters[getterName]);
                                G.Object_defineProperty(proto, getterName, desc);
                            }
                        }
                    }
                }
            }
            allowGetterInterposition();

            function blockShadowRoot() {
                var desc = G.Object_getOwnPropertyDescriptor(G.Element_prototype, "shadowRoot");
 
                function mkgetter(lookupName, orig) {
                    return function () {
                        if (G.Object_hasOwnProperty(this, [lookupName])) {
                            return this[lookupName];
                        } else {
                            return orig(this);
                        }
                    };
                }
                desc.get = mkgetter("_micasa_getter_shadowRoot", G.Element_prototype_shadowRoot);
                G.Object_defineProperty(G.Element_prototype, "shadowRoot", desc);

                G.Element_prototype.createShadowRoot = function () {
                    if (that.inUse) {
                        G.console_error("Cannot use shadowroots after using extension.");
                        return null;
                    }

                    // Allow it. But fail if the page subsequently opens a keyring.
                    G.console_warn("Page using shadowRoots");
                    that.usedShadowRoots = true;
                    return G.Element_prototype_createShadowRoot(this);
                };
                
            }
            blockShadowRoot();
        },

        maim: function () {
            // disable the use of micasa in this document
            this.mon.send("_maim", {params: {}});
            closureIsMaimed = true;

            this.mon.send = function () {
                G.console_error("Monitor cannot be contacted.");
                throw new E(E.MAIMED);
            };
        },

        isPrivateElt: function (domElt) {
            return G.Object_hasOwnProperty(domElt, ["micasa_private_id"]);
        },

        isPrivateHost: function (domElt) {
            return G.Object_hasOwnProperty(domElt, ["micasa_private_host"]);
        },

        _deleteShadowRoot: function (domElt) {
            G.Object_defineProperty(domElt, "_micasa_getter_shadowRoot", {
                configurable: false,
                enumerable: false,
                value: undefined,
                writable: false
            });
        },

        _getPrivateHostConv: function (domElt) {
            var convid = G.Object_getOwnPropertyDescriptor(domElt, "micasa_private_host_convid");
            if (convid) {
                    return convid.value;
            } else {
                return null;
            }
        },

        _brandPrivateHost: function (node, number, handle) {
            // All light DOM hosts are marked as such.
            // This needs to be done in the contentscript too.
            G.Object_defineProperty(node, 'micasa_private_host', {
                configurable: false,
                enumerable: false,
                value: number,
                writable: false
            });

            if (handle) {
                G.Object_defineProperty(node, 'micasa_private_host_convid', {
                    configurable: false,
                    enumerable: false,
                    value: handle,
                    writable: false
                });
            }
        },

        _brandPrivateElt: function (node, number) {
            // All private nodes are marked as such.
            // This needs to be done in the contentscript too.
            G.Object_defineProperty(node, 'micasa_private_id', {
                configurable: false,
                enumerable: false,
                value: number,
                writable: false
            });
        },

        markPrivateElt: function (domElt, keyhandle) {

            var that = this;
            var serialno;
            var succeeded = false;

            if (!(domElt instanceof Element)) {
                throw new E(E.INVALIDPAREA, "Object is not an Element");
            }

            if (this.isPrivateElt(domElt)) {
                G.console_error("Element is already marked private. Node leaked.", domElt);
                this.maim();
                throw new E(E.INVALIDPAREA, "Node is private !?");
            }

            if (this.isPrivateHost(domElt)) {
                G.console_warn("Element is already hosting private nodes.", domElt);
                throw new E(E.INVALIDPAREA, "Element is already hosting private nodes.");
            }


            // 1. provide some lookup mechanism so that the content script can find the DOM node
            serialno = ++this.privateEltCounter;
            G.Element_setAttribute(domElt, ["data-micasa-lookup", "" + serialno]);

            var domQuery = "[data-micasa-lookup='" + serialno + "']";

            var placeholder = null;  // holds domElt's original
                                     // position in the tree amongst
                                     // its siblings.

            var invisiDiv = null;    // is added as a child of the
                                     // documentElement to contain
                                     // domElt temporarily (if domElt
                                     // is detached).

            // its parent (may be null)
            var pNode = G.Node_prototype_parentNode(domElt);

            // if not found in tree (detached).
            if (G.document.querySelector(domQuery) !== domElt) {
                invisiDiv = G.document_createElement("x");
                invisiDiv.style.display = "none";

                // it has siblings. remember its relative position
                if (pNode !== null) {
                    placeholder = G.document_createElement("x");
                    G.Node_prototype_replaceChild(pNode, [placeholder, domElt]);
                }

                G.Node_prototype_appendChild(invisiDiv, [domElt]);
                G.Node_prototype_appendChild(G.documentElement, [invisiDiv]);
            }


            /*
              Note: In the case where the given domElement is not
                    reachable from <html> The content script will not
                    be able to find the node. Should we fail early, or
                    do the operation in two shots?
            */

            if (G.Element_prototype_shadowRoot(domElt)) {
                G.console_error("Element already using shadowRoot");
                throw new E(E.INVALIDPAREA, "Incompatible shadowRoot use.");
            }

            /* We assume that the event in the contentscript will run immediately.
               If the shadowRoot isn't created, then we assume that the operation failed.

               The contentscript has to run immediately, because it is the one creating the
               shadowRoot, and it has to be deleted here just after.
            */
            var sent = this.mon.send("mark_private", {params: {keyhandle: keyhandle, parent: serialno}});
            sent["catch"](function (err) {
                if (succeeded === true) {
                    G.console_error("mark_private eventually failed. Fatal.", err);
                    that.maim();
                }
            });

            // Whatever's rooted at the shadowRoot should be now clean
            // from direct manipulation, but is potentially affected
            // by prototype overriding on HTMLShadowRootElement.
            var shadow = G.Element_prototype_shadowRoot(domElt);

            if (!shadow) {
                G.console_error("Contentscript failed to create an appropriate shadowRoot");
                throw new E(E.INVALIDPAREA, "Failed to create private area");
            }

            shadow.addEventListener("keypress", function (evt) {
                G.console_debug("SHADOW Keypress:", evt.keyCode, evt);
            }, true);

            /* mark node as being a host -- cannot be undone */
            this._brandPrivateHost(domElt, serialno, keyhandle);

            /* hide the shadowroot */
            this._deleteShadowRoot(domElt);

            // Leave DOM unchanged as much as possible

            if (invisiDiv !== null) {
                G.Node_prototype_removeChild(invisiDiv, [domElt]);
                G.Node_prototype_removeChild(G.documentElement, [invisiDiv]);

                if (placeholder !== null) {
                    G.Node_prototype_replaceChild(pNode, [domElt, placeholder]);
                }

                pNode = null;
                invisiDiv = null;
                placeholder = null;
            }

            G.Element_removeAttribute(domElt, ["data-micasa-lookup"]);

            function brandNodes(n) {
                var i, child, childNodes;
                if (!(n instanceof G.Node)) {
                    G.console_error("Impure tree.", n);
                    return false;
                }
                if (n instanceof G.HTMLShadowElement) {
                    G.console_error("Found Shadow element insertion point under shadow tree. Not allowed.", n);
                    return false;
                }

                that._brandPrivateElt(n);
                childNodes = G.Node_prototype_childNodes(n);

                i = 0;

                while ((child = G.NodeList_item(childNodes, [i++])) !== null) {
                    if (!brandNodes(child)) {
                        return false;
                    }
                }
                return true;
            }
            
            // Recurse through children of shadow element and add private markers.
            if (brandNodes(shadow) !== true) {
                G.console_error("Problem marking shadow tree nodes as private. Fatal.");
                that.maim();
                throw new E(E.GENERIC, "Problem marking shadow tree nodes as private. Fatal.");
            }

            succeeded = true;
            return true;
        }
    };

    function _defineImmDesc(obj, propName, val, isEnumerable) {
        /*
          Define an immutable data descriptor on @obj, named @propName
          with initial value @val.  We check that the property cannot
          be redefined and return the status of the immutability.
        */
        isEnumerable = isEnumerable || false;

        G.Object_defineProperty(obj, propName, {
            configurable: false,
            enumerable: isEnumerable,
            value: val,
            writable: false
        });

        if (obj[propName] !== val) {
            G.console_error("Define Property failed.");
            return false;
        }

        try {
            obj[propName] = {};
        } catch (err) {
            if (err.message.indexOf("Cannot assign to read only property '" + propName + "'") === -1) {
                G.console_error("Failed to protect immutable data descriptor via assignment.");
                return false;
            }
        }

        try {
            delete obj[propName];
        } catch (err) {
            if (err.message.indexOf("Cannot delete property '" + propName + "'") === -1) {
                G.console_error("Failed to protect immutable data descriptor via deletion.");
                return false;
            }
        }

        try {
            G.Object_defineProperty(obj, propName, {
                configurable: false,
                enumerable: false,
                value: {},
                writable: false
            });
        } catch (err) {
            if (err.message.indexOf("Cannot redefine property: " + propName) === -1) {
                G.console_error("Failed to protect immutable data descriptor via redefinition.");
                return false;
            }
        }

        return true;
    }

    var monitor = new MicasaMonitor();
    var runtime = new MicasaRuntime(monitor);

    var API = {
        E: E,
        
	//KEY MANAGEMENT
        use_keyring: function (keyringid) {
            if (runtime.usedShadowRoots) {
                G.console_error("[Micasa] Cannot use extension after having created shadowRoots");
                runtime.maim();
            }
            runtime.inUse = true;
            return monitor.send("use_keyring", {params: {keyringid: keyringid}}).catch(function (err) {
                if (err.code === E.NOKEYRING) {
                    return monitor.send("new_keyring", {params: {keyringid: keyringid}});
                }
                throw err;
            });
        },
        new_keyring: function (keyringid) {
            return monitor.send("new_keyring", {params: {keyringid: keyringid}});
        },

        // Promises a friendship handle (initiates the KAP)
        get_friend: function (username) {
            return monitor.send("get_friend", {params: {username: username}});
        },

        // Promises a friendship handle (or null if the user isn't a friend)
        is_friend: function (username) {
            return monitor.send("is_friend", {params: {username: username}});
        },

        
        post_keys: function (username) {
            return monitor.send("post_keys", {params: {username: username}});
        },

        post_tweets: function (tags, keys) {
            return monitor.send("post_tweets", {params: {tags: tags, keys: keys}});
        },

        get_twitter_stream: function () {
            return monitor.send("get_twitter_stream", {});
        },

        /**
           on: add an application handler for extension events

           @param {string} event_type (generally "message")
           @param {function} handler

           * message handler: function (msg) { ... } *

             "message" handler receives a message. It is the
             application's responsibility to route messages between
             users. The following information (`to`, and `from`) in
             the message should be read to make routing decisions.
          
             each message has the following structure:

                  msg := {
                     hdr: {
                         from: <username>,
                         to:   <username>,
                         ...
                     }
                  ...
                  }
              
        */
        on: function (event_type, handler) {
            return monitor.addHandler(event_type, handler);
        },

        /**
           off: remove an installed event handler for extension events
           @param {string} event_type
           @param {function} handler
        */
        off: function (event_type, handler) {
            return monitor.removeHandler(event_type, handler);
        },

        /**
           route a message to the extension.
           Promises true if the msg has been handled successfully.
        */
        message: function (msg) {
            if ((typeof msg) === "string") {
                msg = JSON.parse(msg);
            }
            return monitor.send("app_message", {params: {msg: msg}});
        },

        // Promises an invitation handle. If the current user refuses
        // to invite the other person, this will reject. The promised
        // invitation message must be routed to the other user by the
        // application.
        //
        //   @friend: friendship handle as returned by get_friend
        //   @convid: the conversation streamid
        //
        // Privacy Note: The invitation message contains sufficient
        // information to reconstruct the stream key on the other
        // end. The current user must consent to share the contents of
        // the stream, regardless of whether or not the invitation is
        // ever accepted or not.
        invite: function (friend, streamid) {
            return monitor.send("invite", {params: {friend: friend, convid: streamid}});
        },

        //
        // Promises a convid, based on a received invitation message.
        // The key backing the convid is the same on the sending end
        // of the invitation and the receiving end.
        //
        accept_invite: function (invite) {
            return monitor.send("accept_invite", {params: {invite: invite}});
        },

        // creates a stream (alias)
        new_conv: function () {
            return monitor.send("new_stream", {params: {}});
        },

        new_anon_conv: function () {
            return monitor.send("new_anon_stream", {params: {}});
        },

        new_stream: function () {
            return monitor.send("new_stream", {params: {}});
        },

        collect: function () {
            var stats = monitor._collectStats;
            monitor._collectStats = [];
            return stats;
        },

        test_enabled: function () {
            return 1 && (ENABLE_TEST);
        },

//# if ENABLE_TEST
        fetch_public : function (username) {
            return monitor.send("fetch_public", {params: {username: username}});
        },

        post_public : function () {
            return monitor.send("post_public", {params: {}});
        },

        check_twitter : function () {
            return monitor.send("check_twitter", {params: {}});
        },

        refresh_twitter : function () {
            return monitor.send("refresh_twitter", {params: {}});
        },

        // benchmarking
        encrypt_node: function (domId, keyhandle) {
            return monitor.send("encrypt_node", {params: {domid: domId, keyhandle: keyhandle}});
        },

//# endif //ENABLE_TEST

        //PRIVATE INPUT

        /* Unlike the other functions. This one is synchronous.
           Returns true on success. throws an exception on error.
        */
        mark_private: function (domElt, convid) {
            return runtime.markPrivateElt(domElt, convid);
        },

        is_private: function (domElt) {
            if (runtime.isPrivateHost(domElt)) {
                return runtime._getPrivateHostConv(domElt);
            } else {
                return null;
            }
        },

        /*
          name='highlight' params={re: <regex string>}
        */
        exec_plugin: function (hostElt, name, pluginParams) {
            if (!runtime.isPrivateHost(hostElt)) {
                throw new E(E.INVALIDPAREA, "not a private host");
            }
            var num = G.Object_getOwnPropertyDescriptor(hostElt, "micasa_private_host").value;
            return monitor.send("exec_plugin", {params: {
                parent: num,
                name: name,
                params: pluginParams || {}
            }});
        },

        // Render the ciphertext given into the private area elt @hostElt
        // Promises a success indication boolean.
        //
        // called put_plain(dom_el, cipher) in paper.
        darken: function (hostElt, ciphertext) {
            if (!runtime.isPrivateHost(hostElt)) {
                throw new E(E.INVALIDPAREA, "not a private host");
            }
            var num = G.Object_getOwnPropertyDescriptor(hostElt, "micasa_private_host").value;
            return monitor.send("darken", {params: {parent: num, ciphertext: ciphertext}});
        },

        //like darken but decrypts with elGamal
        darken_elGamal: function (hostElt, ciphertext) {
            if (!runtime.isPrivateHost(hostElt)) {
                throw new E(E.INVALIDPAREA, "not a private host");
            }
            var num = G.Object_getOwnPropertyDescriptor(hostElt, "micasa_private_host").value;
            return monitor.send("darken_elGamal", {params: {parent: num, ciphertext: ciphertext}});
        },

        // Extract the plaintext from the private area element hostElt
        // Promises ciphertext
        //
        // called get_cipher(dom_el) in paper.
        lighten: function (hostElt) {
            if (!runtime.isPrivateHost(hostElt)) {
                throw new E(E.INVALIDPAREA, "not a private host");
            }
            var num = G.Object_getOwnPropertyDescriptor(hostElt, "micasa_private_host").value;
            return monitor.send("lighten", {params: {parent: num}});
        },

    
        //Like lighten, but promises an array of ciphertext encrypted using elGamal
        lighten_multiple: function (hostElt) {
            if (!runtime.isPrivateHost(hostElt)) {
                throw new E(E.INVALIDPAREA, "not a private host");
            }
            var num = G.Object_getOwnPropertyDescriptor(hostElt, "micasa_private_host").value;
            return monitor.send("lighten_multiple", {params: {parent: num}});
        }
        
    };
        
    var export_obj = {};
    if (!_defineImmDesc(window, API_GLOBAL, export_obj)) {
        return runtime.maim();
    } else {
        var propName;
        for (propName in API) {
            if (API.hasOwnProperty(propName)) {
                var func = API[propName];
                if (!_defineImmDesc(export_obj, propName, func, true)) {
                    return runtime.maim();
                }
            }
        }
    }
}
